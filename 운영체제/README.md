

# 운영체제 소프트웨어


### 운영체제 과목 소개
- 컴퓨터사이언스(전공)필수 과목
- **컴퓨터 구조**는 컴퓨터 하드웨어 Scratch
- **운영체제**는 컴퓨터 소프트웨어 + 컴퓨터 하드웨어 Scratch
- 자료구조, 알고리즘
  - 큐, 스택


### 목차
**운영체제 이해**
- 운영체제 intro
  - [대표적인 운영체제](#대표적인운영체제)
  - [운영체제 역할1](#운영체제역할1): 시스템 자원(System Resource) 관리자
  - [운영체제 역할2](#운영체제역할2): 사용자와 컴퓨터 간의 커뮤니케이션 지원
  - [운영체제 역할3](#운영체제역할3): 컴퓨터와 하드웨어와 프로그램을 제어
- 운영체제 큰 그림과 응용프로그램
  - [응용 프로그램](#응용프로그램)
- [운영체제 히스토리](#운영체제History)
  - [1950년대](#1950년대)
  - [1960년대](#1960년대)
  - [1970년대](#1970년대)
  - [1980년대](#1980년대)
  - [1990년대](#1990년대)
  - [2000년대](#2000년대)
- [운영체제 구조](#운영체제구조)
  - [OS관계도 : 커널, 쉘, 시스템콜](#OS관계도)
  - [CPU Protection Rings](#CPUProtectionRings)
**프로세스와 스케쥴링 이해**  
- 프로세스 스케쥴링
  - [멀티 태스킹과 멀티 프로세싱](#멀티태스킹과멀티프로세싱)
  - [멀티 프로그래밍](#멀티프로그래밍)
  - [SystemBus](#SystemBus)
- 스케쥴링 알고리즘
  - [FIFO](#FIFO)  
  - [SJF](#SJF)
  - [우선순위기반](#우선순위기반)
  - [RoundRobin](#RoundRobin)
- 프로세스상태와 스케쥴링
  - [프로세스 상태기반 스케쥴링 알고리즘 기본](#프로세스상태기반스케쥴링알고리즘기본)  
- [선점형과 비선점형 스케쥴러](#선점형과비선점형스케쥴러)
  - [스케쥴러 동작 비교](#스케쥴러동작비교)
  - [스케쥴링알고리즘조합](#스케쥴링알고리즘조합)
- [인터럽트](#인터럽트)
  - [인터럽트와 시스템 콜(고급)](#인터럽트와시스템콜)
- [프로세스 구조](#프로세스구조)
  - [프로세스와 프로그램의 동작](#프로세스와프로그램의동작)
  
***

### 운영체제역할1 
: 시스템 자원(System Resource) 관리자
 
 - Operation System 또는 OS라고 부릅니다.
 - 시스템 자원(System Resource) = 컴퓨터 하드웨어
   - CPU (중앙처리장치), Memory (DRAM, RAM)
   - I/O Devices (입출력장치)
     - Monitor(출),Mouse,Keyboard(입),Network(입,출)
   - 저장매체 : SSD(슬래쉬 메모리), HDD (하드디스크)  => 컴퓨터를 꺼도 자동저장

```
시스템 자원이라고 하는 것은 컴퓨터 하드웨어라고 생각하면 되고,
하드웨어에는 아래와 같은 장치들이 있는 것. 
운영체제의 주요한 역할은 컴퓨터하드웨어를 관리하는 소프트웨어다.
```


<u>**😱 컴퓨터 하드웨어는 스스로 할 수 있는 것이 없다.**</u>


1.  CPU : 각 프로그램이 얼마나 CPU를 사용하지 결정할 수는 없다. 
2. Memory : 각 프로그램이 어느 주소에 저장되어야 하는지, 어느 정도의 메모리 공간을 확보해줘야 하는 지를 메모리 자체가 결정할 수는 없다.
3. 저장매체(SSD,HDD) : 어디에 어떻게 저장할지는 결정할 수 없음.
4. 키보드/마우스 : 스스로 결정,표시할 수는 없다.


> 누가 하느냐 ? 운영체제가 한다.
>> 그래서 운영체제가 필요하다.


*How did we ever run Computer wihtout OS?*
- OS(운영체제) 미설치된 노트북
(하드웨어가 있더라도 운영체제가 없으면 할 수 있는 게 없음)
[https://www.youtube.com/watch?](https://www.youtube.com/watch?v=e9FrlIvlN38&feature=youtu.be&t=29s)

===> 운영체제 없이는 하드웨어가 동작하지 않는다.



### 대표적인운영체제
- Windows OS, Mac Os, UNIX(유닉스 - 최초로 구현)
(맥과 윈도우는 유닉스를 기반으로 설계됨)/br
- UNIX OS : 사라졌는데 왜 공부해?
  - UNIX 계열 OS 
    - UNIX와 사용법이나, OS구조와 유사
  - LINUX(리눅스) OS 
    - 프로그래머, 전공자 필수


*OS는 만들기가 쉽지 않다(수 년간의 시간이 걸림)*
- TmaxOS 시연 사례
(화면 꺼짐..)
[https://www.youtube.com/watch?](https://www.youtube.com/watch?v=OylmhpqptkY&feature=youtu.be)


- Window OS 시연 사례
(블루스크린 뜸...)
[https://www.youtube.com/watch?](https://www.youtube.com/watch?v=nA2SQcaB0ok&feature=youtu.be)


### 운영체제역할2 
: 사용자와 컴퓨터 간의 커뮤니케이션 지원

![](https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.fun-coding.org%2Fwhatisos.html&psig=AOvVaw288oHJzJ_5vTSCLLum_fQf&ust=1603544076620000&source=images&cd=vfe&ved=0CAIQjRxqFwoTCOCEgazhyuwCFQAAAAAdAAAAABAD)


### 운영체제역할3
: 컴퓨터와 하드웨어와 프로그램을 제어

![](https://media.vlpt.us/images/underlier12/post/6777ac36-abec-458e-832d-5ddbfecad7c9/image.png)

- 카톡,한글, 엑셀  :프로그램 //응용프로그램이라고도 하는 데 뒤에서 설명
- OS : [네모박스] 기능들. 컴퓨터하드웨어와 응용프로그램을 제어, 효율적으로 지원해 주기 위해서 운영체제 안에 들어가 있는 여러가지 기술들이라고 생각하면됨.
- CPU,RAM,DB : 하드웨어

===> 누가 한글프로그램을 실행하니? **운영체제가 시켜준다.** 

- Shell이라는 소프트웨어가(운영체제역할2에서 사용자와 컴퓨터간의 커뮤니케이션 지원) 주로 담당함. 

**요약**
```
운영체제역할 - 컴퓨터하드웨어를 관리하는역할, 시스템자원관리자, 
사용자와 컴퓨터간의 커뮤니케이션 지원, 
운영체제가 하드웨어 뿐만아니라 응용 프로그램까지도 관리함.
```



## 응용프로그램
- 프로그램 : 소프트웨어
- 소프트웨어 : 운영체제, 응용 프로그램(엑셀,파워포인트, 당신들이 만드는 프로그램.)
- 응용 프로그램 : Application(일반 PC에서의 프로그램) = App(스마트 폰에서 응용프로그램)


### 운영체제와 응용 프로그램 간의 관계
운영체제 역할 1: 시스템 자원(System Resource)관리자/br
운영체제 역할 2: 사용자와 컴퓨터간의 커뮤니케이션 지원/br
운영체제 역할 3: 컴퓨터 하드웨어와 **응용 프로그램**을 제어/br

- 운영체제의 목표 : 사용자가 사용하는 응용 프로그램이 효율적으로, 적절하게 동작하도록 지원
- 운영체제는 응용 프로그램이 요청하는 시스템 리소스를 효율적으로 분배하고, 지원하는 소프트웨어

*운영체제는 응용프로그램을 관리*
  - 응용 프로그램을 실행시킨다.
  - 응용 프로그램 간의 **권한**을 관리해준다.
    - **관리자 권한으로 실행**(운영체제에서 제공)
  - 응용 프로그램을 사용하는 **사용자**도 관리
    - 로그인
    
*응용 프로그램은 누구나 만들 수 있다*
   - 응용프로그램에 무한 반복문을 넣었다.
    - 응용프로그램을 잘 못 작성해서, 프로그램이 다운
    - 모든 파일 삭제 막기(권한/사용자 관리)
    - 응용프로그램이 욕심이 많아서, CPU를 자기만 쓰겠다 <--


*응용체제는 어디에 있나용,,*

 - 운영체제는 저장매체(SSD/HDD)에 저장(설치)이 됩니다.


### 컴퓨터 구조 복습

> 컴퓨터 키면 ?
>> 운영페제는 Memory에 올라가게 됩니다.

참고: 폰노이만 구조

![](https://media.vlpt.us/images/underlier12/post/60c97d3c-ff6c-498d-a218-5a6dd906f40a/image.png)


**정리**
```
운영체제의 역할: 
1.시스템 자원 
2.응용프로그램 관리
3.효율적 분배
응용 프로그램이란? : 소프트웨어 (운영체제, 응용 프로그램)
```


## 운영체제History

### 1950년대
**1950년대**
> ENIAC : 첫 번째 컴퓨터
>> 운영체제가 없었습니당,,,*
>>> 1개의 응용 프로그램을 실행시키기도 바빴다..
>>> (응용 프로그램이 시스템 자원을 제어하며 실행했다.
![](https://t1.daumcdn.net/cfile/tistory/26667D4D568E20AA10)


### 1960년대
**1960년대 초기**
> 프로그램 종류도 많아지고, 사용자도 슬슬 많아지기 시작
> - 철수 : 프로그램 1 = 예상 실행시간 12시간
> - 영희 : 프로그램 2 = 예상 실행시간 1분
>> ==> 프로그램1 --> 프로그램2/br
>> ==> 프로그램2 --> 프로그램1
>> (프로그램이 언제끝날지 몰라 영희는 철수의 프로그램1을 계속 지켜보고 있어야함..)
>>> ==> 배치 처리 시스템(batch processing system)출현
>>> - 여러 응용 프로그램을 등록시켜 놓으면, 순차적으로 실행하는 시스템
>>> - 배치 처리 시스템을 기반으로 운영체제가 출현


![](https://www.codentalks.com/uploads/default/original/2X/9/9507e63378653c0c394b2a9ebde1dbe1ef73d046.jpeg)

![](https://user-images.githubusercontent.com/40616436/75155492-88f6d000-5753-11ea-8de4-6b8b52f4d0a7.png)

막대 : 시간축 

`application 1` : (가정)12시간정도 걸리는 프로그램이다.

`application 2` : (가정) 2시간정도 걸리는 프로그램이다. /br

**배치 처리 시스템** : 등록(순서 포함) 자동으로 해당 운영체제가 다음으로 등록된 `application 2`를 실행시키는 것 (순서가 중요해짐)

**배치 처리 시스템 단점** 
```
1. 컴퓨터 응답시간(response time)이 오래걸릴 수 있다(앞 단에 실행시간이 많이 필요로하는 응용 프로그램이 실행될 경우)
2. 실행시간도 오래걸릴 수 있습니다.(CPU필요 없음에도 응용 프로그램이 CPU를 점유할 수 있기 때문에)
```

**1960년대 후기**
> 새로운 개념이 제안됨
>> - 시분할 시스템(Time sharing System)
>> - 멀티 태스킹(Multi Tasking)
>> (개념자체는 비슷 목적은 다름)... 운영체제로 구현되지는 못했다.
- 시분할시스템과 멀티태스킹 
  - **시분할 시스템**: 응용프로그램이 CPU를 사용하는 시간을 잘개 쪼개서, 여러 개의 응용프로그램을 동시에 실행하는 기법/컴퓨터 응답시간 낮추기 ↓
  (목적 : 다중 사용자를 지원하고, 컴퓨터 응답시간을 최소화하는 시스템을 목적)
![](https://media.vlpt.us/images/underlier12/post/e9c5b2d9-1867-49d4-be98-1667b87c59a6/image.png)
- 배치프로그램에서가 아니라, 시분할 시스템처럼 1초씩 실행된다면 ?   
`application 1`과 `application 2` 가 1초씩 기능에 따라 조금씩 처리가 됨. ==> 다중 사용자 지원

- **멀티 태스킹**:  단일 CPU에서, 여러 응용 프로그램의 병렬 실행을 가능케 하는 시스템)
  (목적: 가능한 CPU를 많이 활용하도록 하는 기능(시간대비 CPU사용률을 높이자↑ ))    
==> 결국에는 시간을 잘개쪼개서 여러 프로그램을 돌리는 것 

- **멀티 프로그래밍** : 최대한 CPU를 많이 활용하도록 하는 시스템(시간대비), CPU활용도를 높이자

![](https://media.vlpt.us/images/underlier12/post/c3abf97e-690b-4674-a81e-75e4fd8f75a4/image.png)

`application 3`이 파일을 열고 저장매체에서 파일을 읽는 동안 CPU는 멈춰있음. 
==> 그래서 읽는 동안 `application 1`로 변경하여 CPU활용

==> `application 2`도 추가하여 쪼개서 함께 실행

![](https://media.vlpt.us/images/underlier12/post/5f6158f9-f3b5-4309-941d-ea8aa84274a5/image.png)


**시분할시스템/멀티태스킹 장점**
- 핵심 기술 : 시간을 잘게 쪼개서, 여러 응용 프로그램을 실행
  - 배치프로그램의 단점 보안
  - 컴퓨터 응답시간을 줄일 수 있음(시분할 시스템, 다중 사용자를 지원)
  - 전체 응용 프로그램의 실행 시간도 줄일 수 있음
  - 결과적으로, 사용자가 느낄 때에는, 여러 응용프로그램이 동시에 실행되는 것처럼 보인다. 

### 1970년대
**1970년대**
> 제대로된 운영체제가 나왔다
>> UNIX(유닉스) OS
>> 미국 AT&T 사의 벨 연구소 (켐톤슨, 데니스 리치 : C언어 개발)

<img src = "https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F25665C41548C020722" width="400px">



*운영체제 개발에 C언어가 필요했던 이유*
  - 1970년대 이전 : Assembly언어로 소프트웨어 개발
    - CPU(명령어), Memory(주소)
    - 컴퓨터마다 각각 다시 개발해줘야하는 단점
    - 프로그래밍 복잡도가 높음 
  - 1970년대 C언어가 개발된 후 
    - 컴파일러가 Assembly언어로 되어 있는 걸 기계어로 바꿔줘서 호환가능해짐(한번 C언어로 만들어진 코드는 작성할 필요가 없어지게 됨.)
    - 프로그래밍 복잡도는 낮음.
    
    ==> C언어를 기반으로 운영체제를 개발했따.


### UNIX특징
- 현대 운영체제의 기본 기술을 모두 포함한 최초의 운영 체제
  - 멀티태스킹, 시분할 시스템, 멀티 프로그래밍
     - 다중사용자 지원
  - UNIX의 생김새 ☟ (로그인 할 수 있어짐)   
[https://www.youtube.com/watch?v=Aj1n2_qEq5k&feature=youtu.be](https://www.youtube.com/watch?v=Aj1n2_qEq5k&feature=youtu.be)

### 1980년대
**1980년대**
> 개인용 컴퓨터 시대 
>> 1980년대 이전 : 대형 컴퓨터를 여러명이 접속해서 사용(유닉스)
>> 1980년대 초반 : CLI --> GUI  (아직 터미널 환경)
>> [CLI --> GUI 넘어가는 과정 << 영상보기](https://www.youtube.com/watch?v=f_Q0XPher3o&feature=youtu.be)
>> 1980년대 ~ : Personal Computer(PC) - 개인용 PC보급화
>>> 1980년대 중후반 GUI 환경 (마우스)
>>> [apple사의 마우스 광고](https://www.youtube.com/watch?v=cvjLc24VbI8)

*용어이해*
 - CLI(Command Line Interface) : 터미널 환경 -> 키보드, 검은화면
 - GUI(Graphical User inteface) : GUI환경 -> 마우스
 ![](https://sciencerack.com/wp-content/uploads/2018/06/GUI-vs-CUI-min.jpg)
 
 
 ### 1990년대 
 **1990년대**
> 응용프로그램 시대 by GUI환경, 개인용 컴퓨터(사용자 증대)
>엑셀, 워드 프로세서 등등
>Windows OS 대중화
>> 네트워크 기술 발전 - 월드와이드웹(www) 인터넷 대중화
>>> 오픈 소스 운동 활성화 시작 (==> 기술은 공유되어야 한다 !!)
>>> UNIX 개열 OS + 응용 프로그램 자체 개발, 소스 오픈
>>> LINUX (리눅스) 운영페제, 소스 오픈, 무료
  
  
*Killer Application*
1. 위닝(축구게임)게임 프로그램을 위해 플레이스테이션 기기를 구매함
2. 엑셀 프로그램을 사용하기 위해서, Windows 컴퓨터를 구매.


### 2000년대 
> 오픈 소스 활성화
> LINUX(리눅스) 운영체제
> apache (아파치, 웹서버) - 소스 무료
> MySQL (데이터베이스)
> 요즘.. 안드로이드, 딥러닝, 데이터사이언스, IoT 관련
>> 가상 머신, 대용량 병렬 처리등 활성화


**정리**
```
1950년대 : 운영체제가 없었음, 응용프로그램이 직접 시스템 자원을 제어하며 실행
1960년대 초기 : 배치 처리 시스템 출현, 운영체제가 출현
1960년대 후기 : 시분할 시스템/멀티 태스킹/멀티 프로그래밍 개념의 등장. (기술 : CPU시간 잘게 쪼개기, 결과 : 다중사용자 지원, 응용 프로그램 동시 실행)
1970년대 : 본격적으로 운영체제 중요성 부각, 현대 운영체제 기술확립, 유닉스 OS에 최초 구현, 유닉스: 멀티 태스킹, 시불할 시스템, 멀티 프로그래밍 구현
1980년대 : 개인용 컴퓨터 / GUI환경으로 이동
1990년대 : 다양한 응용프로그램 활성화, 네트워크 발전(인터넷), 오픈소스 공유
2000년대 : 오픈 소스 활성화, 가상 머신, 대용량 병렬처리
```

**정리2**
- 운영체제는 응용 프로그램과 시스템 자원을 제어하고, 관리한다.
- 응용프로그램(Application)용어 이해
- 배치처리 시스템(순서대로 기다리기), 시분할 시스템(시간 쪼개기), 멀티 테스킹(동시에 처리하는 것처럼 보이기) 개념
- CLI(터미널), GUI환경 용어 이해
- Histoty 전반 가볍게 알아두기


## 운영체제구조

>응용 프로그램, 운영체제, 컴퓨터 하드웨어(시스템 리소스) 관계
>> 운영체제는 응용 프로그램이 요펑하는 메모리를 허가하고, 분배한다.
>> 운영체제는 응용 프로그램이 요청하는 CPU시간을 제공한다.
>> 운영체제는 응용 프로그램이 요청하는 IO Devieces 사용을 허가/제어 한다.


도서관으로 비유
- 운영체제는 도서관
 - 응용 프로그램을 시민
 - 컴퓨터 하드웨어는 책
 - 운영체제의 역할
   - 시민은 도서관에 원하는 책(자원)을 요청함
   - 도서관은 적절한 책(자원)을 찾아서, 시민에게 빌려줌
   - 시민이 책을 다 읽으면, 기한이 만료되면, 도서관이 해당 책(자원)을 회수함
   
   
> **사용자**, 응용 프로그램, 운영체제, 컴퓨터 하드웨어와 관계
>> Operating ststems
<img src = "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Operating_system_placement.svg/1200px-Operating_system_placement.svg.png" width="400px">

>>> 운영체제는 사용자 인터페이스 제공
>>> - **쉘(Shell)** //예를 들면, 터미널에서 입력하는 명령어(인터페이스=사용법) => 이것을 제공해주는 것이 쉘  : 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램
- 쉘은 터미널 환경(CLI)과 GUI환경 두 종류로 분류됨


### OS관계도
- 운영체제는 응용 프로그램의 요청에 따라 메모리, CPU 시간, IO Device의 사용을 허가하고 분배 및 제어한다.
<img src = "https://media.vlpt.us/images/underlier12/post/2b8f5464-5db5-4291-b79b-d39f1910af31/image.png" width="350px">


**요약**
```
사용자에게 인터페이스를 제공해주기 위해서는, 쉘이라는 프로그램을 (마우스든 . 키보드든)이용해서,
입력을 받아서 운영체제에 요청사항을 전달해주는 것이고,
응용 프로그램은 응용 프로그램 안에 프로그래밍을 언어를 통해 
운영체제에 뭔가를 요청할 수 있기 때문에 APi라는 형태로 응용프로그램을 위한 인터페이스를 제공해준다. 
라이브러리 : 운영체제에 요청할 만한 api를 묶어서 라이브러리 형태로 제공한다. 

API내부에는 시스템콜을 호출하는 형태로 만들어지는 경우가 대부분이고,
open이라는 시스템콜을 운영체제가 제공한다. 
시스템콜은 일종의 요청서다. 

Operating ststems(운영체제는)사용자든, 운영프로그램이든, 외부에서 컴퓨터 자원을 쓰기위해서 
하드웨어에서 요청을 하면 ==> cpu,Memoty..(하위 4개)등이 
"이러이런 걸 요청해주세요"라고 시스템 콜이라는 걸 제공. 
시스템 콜은 운영체제 입장에서 각 기능을 정의한 것이라서 프로그램에서 쓰기엔 사용법이 복잡할 수 있음 ==> 그걸 완화하기 위해. 
api&라이브러리등을 각 언어별로 제공을 하는 것이고, 
다만, api내부를 보면 결국엔 시스템 콜을 통해서 운영체제에게 기능을 요청하게 되는 것.
api&라이브러리를 묶어 놓은 걸 기반으로 해서, 애플리케이션이나 쉘이라는 프로그램을 만드는 것, 
그리고 그 프로그램을 사용자가 사용하는 것.
```

  **API(Applacation Programming Interface)**
    - 함수로 제공 ==> 함수의 집한, 요청서1,2,3...의 집합
    - 각 언어별 운영체제 기능 호출 인터페이스 함수
    - open() 
  - 보통은 (함수의 종류가 너무 많기 때문에) 라이브러리(library) 형태로 제공 
    - C library //[https://www.gnu.org/software/libc/](https://www.gnu.org/software/libc/)
    
  *운영체제는 응용 프로그램을 위해서도 인터페이스 제공*
  
**시스템 콜**
  - 시스템 콜 또는 시스템 호출 인터페이스
  - 운영체제가 운영체제 각 기능을 사용할 수 있도록 시스템 콜이라는 명령 또는 함수를 제공
  - API내부에는 시스템콜을 호출하는 형태로 만들어지는 경우가 대부분
  - open이라는 시스템콜을 운영체제가 제공한다.
  - 그리고 그걸 라이브러리로 제공하는 경우가 많다. 
  

*운영체제를 만든다면 ?*
 1. 운영체제를 개발한다. (kernel)
 2. 시스템 콜을 개발
 3. C API(라이브러리)
 4. Shell 프로그램
 5. 응용 프로그램 개발
 
*운영체제와 시스템 콜*
- 시스템 콜 정의 예
  - POSIX API(포식스) - 각각의 시스템 콜에 대한 정의 제공, 윈도우 API 

**정리**
```
API - 각 언어별 운영체제기능 호출 인터페이스 함수(각 언어별 인터페이스)
시스템 콜 - 운영체제 기능을 호출하는 함수

- 운영체제는 컴퓨터 하드웨어와 응용 프로그램을 관리한다.
- 사용자 인터페이스를 제공하기 위해 쉘 프로그램을 제공한다
- 응용 프로그램이 운영체제 기능을 요청하기 위해서, 운영체제는 시스템 콜을 제공한다.
  - 보통 시스템 콜을 직접 사용하기 보다는, 해당 시스템 콜을 사용해서
  만든 각라이브러리 (API)를 사용한다.
```


### CPUProtectionRings
- CPU도 권한 모드라는 것을 가지고 있다
  - 사용자 모드(user mode application)
  - 커널 모드(kernal mode OS) : 특권 명령어 실행과 원하는 작업 수행을 위한 지원 접근을 가능케 하는 모드
  
  ![](https://media.vlpt.us/images/underlier12/post/e23e2a44-d765-4c68-b2d0-30860c112699/image.png)
*(intel CPU기준)*

- ring 3 : 사용자 모드 : 응용프로그램이 사용한다.
- ring 0 : 커널 모드  : OS가 사용한다
- ring 1~2 : 거의 쓰지 않음

*kernal  - 사전적의미 (OS가 쓰는 모드)*
1.견과류 씨앗(알맹이)
2. (사상, 주제의)핵심

*shell*
1. 껍데기

### 응용 프로그램과 운영체제
  - 우리가 만드는 프로그램은 맨 위에서 놀고 있다.
  ![](https://media.vlpt.us/images/underlier12/post/ec3e04ae-bef4-4599-ba31-0be08b7ad9f4/image.png)
  
시스템 호출 인터페이스 : 시스템 콜

> 1~1000 더하고  ==> 시스템 콜 사용할 필요없이 이건 더하기만..하면됨.
>> 파일에서 데이터 가져오기 ==> 파일을 읽어달라는 시스템 콜을 통해서 커널영역에서 수행한 후에 응용프로그램에 전달 -> 3으로 이동
>>> 해당 데이터와 1에의 값을 더한 뒤 출력한다.  ==>결과적으로 응용프로그램에서 실행


*정리 : 어떤 모드는 사용자영역~ 어떤 모드는 커널영역에서 동작한다.*


**시스템 콜은 커널 모드로 실행**
- 커널 모드에서만 `실행가능한 기능(응용프로그램)`들이 있음
- 커널 모드로 실행하려면, 반드시 `시스템 콜(커널모드)`을 사용해야함 (거쳐야함) --> `커널모드 --> CPU실행`
- 시스템 콜은 운영체제 제공
`응용프로그램`에서 사용자 모드로 가서 CPU실행할 지언정 반드시 시스템 콜을 거쳐야함. 


**사용자 모드와 커널모드**
- 함부로 응용 프로그램이 전체 컴퓨터 시스템을 해치지 못함
- 주민등록 등본은 꼭 동사무소 또는 정부24(정부사이트)에서 특별한 신청서를 써야만 발급
  - 동사무소 직원분들은 특별한 권한을 가지고, 주민등록등본 출력 명령을 실행하는 셈
  
  
  *응용 프로그래머와 시스템 프로그래머*
  - 응용 프로그래머 ==> 사용자 프로그램 (API<응용>)
  - 시스템 프로그래머 ==> 하드웨어, 운영체제 및 시스템 프로그램(shell/api/system call)
  

**Code example1**
![](https://media.vlpt.us/images/underlier12/post/edf65967-bc2c-4e90-920b-7cb6e9a0cbc9/image.png)

- open() ==> 저장매체에 있는 파일 오픈 : open- api,system call
- 사용자 모드였다가 id = open(~~) 이 부분부터 커널모드로 바뀜
- 다시 돌아오면 사용자 모드로 돌아옴


**Code example2**
![](https://media.vlpt.us/images/underlier12/post/4218ff68-47e5-4e78-ba32-e295be87bc19/image.png)

- 결과적으로 open 통해 커널안에 들어가  sys_open() 시스템 콜을 처리하는 운영체제 함수에 접근해서 일을 처리하더라. 
- user : api, ~system call(둘의 중간쯤)~
- kernal : system call을 처리하는 운영체제 함수

**정리**
```
- 운영체제는 시스템 콜 제공
- 프로그래밍 언어별로 운영체제 기능을 활용하기 위해, 시스템 콜을 기반으로 API제공
- 응용 프로그램은 운영체제 기능 필요시, 해당 API를 사용해서 프로그램을 작성
- 응용 프로그램이 실행돼서, 운영체제 기능이 필요한API를 호출하면, 시스템 콜이 호출되서, 커널 모드로 변경되어 OS내부에서 해당 명령이 ㅅㄹ행되고, 다시 응용 프로그램으로 돌아간다. 

```

## 프로세스 스케쥴링
배치처리 시스템, 시분할 시스템, 멀티태스킹

프로세스 : 응용 프로그램
스케줄링 : 여러가지 응용 프로그램을 CPU에 여러 방법으로 배치하는 방법


**배치처리시스템**
- 일괄처리, 배치처리, batch processing이라고 부름
- 컴퓨터 프로그램 실행 요청 순서에 따라 순차적으로 프로그램을 실행하는 방식
- 한번에 등록된 여러 프로그램을 순차적으로 실행가능

*배치처리 시스템과 시분할 시스템, 멀티 프로그래밍 왜 나왔어?*
- 여러 프로그램을 순차적으로 실행시킬 수 있도록 해주세요!
  - 어떤 프로그램 실행이 너무 시간이 많이 걸려서, 다른 프로그램 실행하는 데 시간을 많이 기다려야한다. 
> 멀티 프로그래밍 /시분할 시스템이 등장


**시분할 시스템**
- 다중 사용자 지원을 위해 컴퓨터 응답 시간을 최소화하는 시스템

**멀티태스킹**
- 멀티태스킹 : 단일 CPU에서 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템
  - 나는 MP3음악을 들으며, 문서작성을 한다.
  

*실제 멀티 태스킹*
- 1000 밀리초(ms) = 1초
- 10~20ms 단위로도 실행 응용 프로그램이 바뀌더라
- 사용자에게는 동시에 실행되는 것처럼 보임


### 멀티태스킹과멀티프로세싱
![](https://media.vlpt.us/images/underlier12/post/d1bc91d6-d40d-4168-939d-4130046edfa3/image.png)

- 멀티 태스킹: 단일 CPU
- 멀티 프로세싱 : 여러 CPU에 하나의 프로그램을 병렬로 실행해서 실행속도를 극대화 시키는 시스템



### 멀티프로그래밍

- 멀티 프로그래밍
  - 최대한 CPU를 많이 활용하도록 하는 시스템
    - 시간 대비 CPU활동도를 높이자
    - 응용 프로그램을 짧은 시간 안에 실행 완료를 시킬 수 있음
  - 응용 프로그램은 온전히 CPU를 쓰기보다, 다른 작업을 중간에 필요로 하는 경우가 많다. 
    - 응용 프로그램이 실행되다가 파일을 읽는다 ==> 파일을 읽는데에 저장매체에서 읽으므로 매우 느린 과정
    - 응용 프로그램이 실행되다가 프린팅을 한다 ==> 느림
    

![](/image/OS/os.png)

- CPU가 순차적으로 실행될 수 있음
- open()만나는 순간 '저장매체' 다녀와야함. ==> 이 과정 오래걸림 
- open()이 가능한지 안한지에 대한 결과 값이 없으면, 다른 코드로 넘어 갈 수 없음. 판단 된 후 넘어가야함 .. ==> 이 넘어가는 과정을 다른 프로그램으로 바꿔주면 좋다. 


![](/image/OS/os1.png)

CPU 입장에서 `application 3`이 파일을 열고 저장매체에서 파일을 읽는 동안 CPU는 멈춰있음. 
==> `application 3`읽는 동안  `application 1`로 대체 해놓음. 

==> 첫번째 CPU 사용하는 동안 응용프로그램 3개 실행 => CPU사용률 3/8

==> 두번째 CPU 사용하는 동안 응용프로그램 8개 실행 => CPU사용률 100



### 메모리 계층

메모리 계층은 다음과 같으며 CPU에서 멀어질 수록 접근 시간이 기하 급수적으로 늘어나는 것을 알 수 있다.

![](https://media.vlpt.us/images/underlier12/post/62dabb88-864f-4c47-8206-2d5d26696fbf/image.png)

- 레지스터는 데이타 패치하는 싸이클
- L3캐시 이전 -> 40사이클(빠름)
- 200 사이클 -> 시간 늘어남.(버틸만함)
- 저장매채 Flash Drive, Hard Dist (느림)


### SystemBus

컴퓨터 구조 상 CPU는 메모리나 저장 매체 등에 직접 접근하지 않고 DMA를 통해 요청을 하여 데이터를 전달하고 전달 받는다.

![](https://media.vlpt.us/images/underlier12/post/3032aa12-a764-48ec-af8e-e4caf47c99e3/image.png)

- 레지스터는 CPU에 있다.
- 시간을 아끼기 위해 DMA두도록 설계하는 경우도 있음
- 저장매체에서 데이터를 가져올 경우, 응용프로그램은 한동안 활동을 못하고, 다른 응용프로그램으로 바꿔주는 게 CPU의 효율를 높이는 방법이다. 


*정리*
```
실제로는 시분할 시스템, 멀티 프로그래밍, 멀티 태스킹이 유사한 의미로 통용된다. 
[핵심] 
- 여러 응용 프로그램 실행을 가능토록 함
- 응용 프로그램이 동시에 실행되는 것처럼 보이도록 함
- CPU를 쉬지않고 응용 프로그램을 실행토록 해서, 짧은 시간 안에 응용 프로그램이 실행완료 될 수 있도록 함
- 컴퓨터 응답시간도 짧게 해서, 다중 사용자 지원
```

*정리*
```
배치처리시스템 : 실행 요청 순서에 따라 순차적으로 프로그램을 실행
시분할 시스템 : 다중 사용자 지원, 응답시간 최소화 시스템
멀티 태스킹 : 단일 CPU에서 여러 응용 프로그램을 동시에 실행하는 것처럼 보이도록 하는 시스템
멀티 프로세싱 : 여러 CPU에 하나의 프로그램을 병렬로 실행하도록 해서 실행속도를 높이는 기법
멀티 프로그래밍 : 최대한 CPU를 일정 시간당 많이 활용하는 시스템
```
- 반복을 통해 감을 익히는 게 중요!

 
## 스케쥴링 알고리즘

**프로세스(process)란?**
: 실행중인 프로그램은 프로세스라고 함
  - 프로세스 : 메모리에 올려져서, 실행 중인 프로그램
  (폰노이만 구조에서 모든 코드는 메모리에 일단 올려진 후 한줄씩 CPU에 올려져서 실행됨)
  - 코드 이미지(바이너리) : 실행 파일, 예: ELF format

> 프로세스라는 용어는 작업, task, job이라는 용어와 혼용


*잠깐!*
 - 응용 프로그램은 프로세스는 아니다. 
   - 응용 프로그램은 여러개의 프로세스로 이루어 질 수 있음
 - 하나의 응용 프로그램은 여러 개의 프로세스(프로그램)가 상호작용을 하면서 실행될 수도 있음
 > 간단한 C/C++ 프로그램을 만든다면 -> 하나의 프로세스겠지만,
 >> 여러 프로그램을 만들어서, 서로 통신하면서 프로그램을 작성할 수도 있음
 >> (IPC기법 - 프로세스와 통신하는 기법)


*스케쥴러와 프로세스*
> 누가 프로세스 실행을 관리할까요 ? -스케쥴러
> 프로세스의 단위가 스케쥴러


### *스케쥴링 알고리즘?*
> 어느 순서대로 프로세스를 실행 시킬까?
  - 목표 
    - 시분할시스템 예 : 프로세스 응답 시간을 가능한 짧게
    - 멀티 프로그래밍 예 : CPU활용도를 최대한 높혀서 프로세스를 빨리 샐행


### FIFO
**: FIFO(피포) 스케쥴러**
> 프로세스가 저장매체를 읽는 다든지, 프린팅을 한다든지 하는 작업 없이,
> 쭉 CPU를 처음부터 끝까지 사용한다.
> First In First Out 스케쥴러


![](/image/OS/os2.png)

- 가장 먼저 들어온 것 먼저 실행 
- CPU실행 큐에서 없어지면서 1 -> 2,2,2 -> 3
- FCFS(First Come First Served) 스케쥴러 
- 가장 간단한 스케쥴러(배치처리시스템과 유사)

![](https://media.vlpt.us/images/underlier12/post/d18f13cd-4168-4e64-8ac0-3be65119bf09/image.png)
- 프로세서는 CPU를 일컬음


*FIFO는 어디서 배웠을까?*
![](/image/OS/os3.png)
- 큐와 구조와 동일


### SJF

**: 최단 작업 우선(SJF) 스케쥴러**
  - SJF(Shortest Job First)스케쥴러
  - 가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행시키는 알고리즘
  - 특별한 환경이 아닌이상 이상적인 알고리즘
  
  ![](/image/OS/os4.png)
  - 3은 1초, 2는 3초, 1은 2초 이므로 실행순서 ==> 3,1,1,2,2,2
  - 실행시간이 짧은 것을 우선적으로 실행하니 응답시간이 짧을 수 있음.(FIFO처럼 줄줄이 딜레이 될 일은 없음)
  - 실행시간을 다 알아야지만 실행가능. => 단점
  


*알아가기*
*RealTime OS(RTOS)*
- 알티오에스 : 응용 프로그램 실시간 성능 보장을 목표로 하는 OS
  - 정확하게 프로그램 시작, 완료하는 시간을 보장(시간에 민감한 프로세스들이 동작해야하는 곳에 쓰임. 공정같은 곳에 쓰임. 몇시 몇분 몇초에 시작해서 몇시 몇분 몇초에 끝나야하는...)
  - Hardware RTOS, Software RTOS

*General Purpose Os(GPOS)*
  - 프로세스 실행시간에 민감하지 않고, 일반적인 목적으로 사용되는
  OS, 예: Windows, Linux등
  
### 우선순위기반
**: 우선순위 기반 스케쥴러**
- Priority-Based 스케쥴러
  - 우선순위를 어떻게 매긴다는 거야 ??
    - **정적 우선순위**
      - 프로세스마다 우선순위를 미리지정
    - **동적 우선순위**
      - 스케쥴러가 상황에 따라 우선순위를 동적으로 변경
      
      
![](/image/OS/os5.png)

- 빨간색() -> 정적으로 매겨진 우선순위
- 만약 우선 순위가 빨간색 숫자가 높은 순이라면, 위처럼 작동함. 

(현실적으로 모든 프로세스의 우선순위를 미리 지정하는 것은 어려움)



### RoundRobin
**: Round Robin(라운드로빈) 스케쥴러**

![](/image/OS/os6.png)

- 도는 느낌
- 먼저들어간 것이 먼저 실행되긴 하는데, 시분할 시스템 때문에 일정시간 실행후에는 바꿔치기를 하게되고 바꿔치기된 놈은 큐의 뒤로 들어가게 된다.

![](https://media.vlpt.us/images/underlier12/post/5068f777-7901-4f7a-b5be-985b8dec4090/image.png)

**정리**
```
다양한 기본 스케쥴링 알고리즘
- FIFO(FCFS)스케쥴링 알고리즘(배치처리시스템)
- 최단작업우선(SJF) 스케쥴링 알고리즘
- 우선순위기반 스케쥴링 알고리즘
  - 정적우선순위, 동적 우선순위
- RoundRobin 스케쥴링 알고리즘
   - 시분할시스템 기반
```


## 프로세스상태와 스케쥴링

**멀티 프로그래밍과 Wait**
- 멀티 프로그래밍 : CPU활용도를 극대화 하는 스케쥴링 알고리즘
- Wait: 간단히 저장매체로부터 파일 읽기를 기다리는 시간으로 가정

![](https://media.vlpt.us/images/underlier12/post/cf0114b6-1d9b-4a7c-b6c1-905d75517f90/image.png)
- `program A` 는 Run 실제로 CPU실행. 저장매체 등을 사용할때 , wait(기다리는 상태)
- `program B` 실행하면 파일 읽기부터 시작하여 wait하고 run..
- `program C` 한참 wait을 하다가 러닝하고, 기다리다가 다시 러닝..
- `combined` : 3개의 스케쥴러를 실행할때 맨처음 A선택, B선택, C선택.. ==> CPU활용 높이기

어떻게 CPU스케쥴링을 작성해야할까.

**프로세스 상태**
프로세스 상태 정보를 스케쥴러가 필요로 하게됨.
프로세스 상태는 총 3가지가 있음
- running state: 현재 CPU에서 실행하고 있는 상태
- ready state : 지금 CPU에 넣으면 ready state CPU에서 실행가능한 상태(실행 대기 상태)
- block state: 특정 이벤트 발생 대기 상태.(예: 프린팅이 다 되었다!). 저장매체에 파일읽기를 요청했다고 한다면, block state => 다 끝났다 하면 다시 ready state로 돌아감. 

![](https://media.vlpt.us/images/underlier12/post/4358fd61-6d28-4fb1-b2b0-d585ab214b0b/image.png)

### 프로세스상태기반스케쥴링알고리즘기본
**: 프로세스 상태 간 관계**
- ready, running, vlock states

[](https://media.vlpt.us/images/underlier12/post/5d42254e-1a6d-4319-9f38-c152169227b4/image.png)
- Process blocks for input 특정 이벤트 내기
- ready로 변경되면, 스케쥴러가 다음 CPU에 실행할 프로세스 누가 있니? 물었을 때 => 저요저요! 상태
- CPU에 다른 프로세스로 교체해야할 때 다시 running의 상태. 다른 ready 상태의 프로세스를 선택해서 running.
- Ready 상태에서 Running이 될 수 있고 Running 후 Block 또는 Ready 상태로 간다. Block 상태가 끝나면 Ready로 돌아간다.


![](https://github.com/Qussk/TIL/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/OS/os7.png?raw=true)

- 만약 1,2,3 모두가 ready인 상태에서 2를 먼저 시작했다면, 2는 Block. 1,3은 ready상태임. 

*state별로 Queue를 적용*
- Queue를 적용하면 합리적인 알고리즘을 작성할 수 있겠더라.
- Queue(FIFO)

![](https://media.vlpt.us/images/underlier12/post/ab9bf543-879e-4c0a-b4c4-586ad8164f3f/image.png)
- 1,2,3 모두 ready인 상태로 Ready State Queue에 들어가있음

![](https://media.vlpt.us/images/underlier12/post/9d395dfb-3cdd-4d6f-a908-4de8bed1423b/image.png)

- 1을 선택(pop)을 통해 해당 큐로부터 프로세스를 가져와 처리하고 실행중이기 때문에 Running State Queue에 삽입됨.

![](https://media.vlpt.us/images/underlier12/post/10d589bb-8b4a-4971-aaf2-062d6e920568/image.png)
- 진행 후에 프로세스 1은 여전히 진행가능하기에 다시 Ready State Queue에 들어가고 맨 뒤에 삽입된다. 

![](https://media.vlpt.us/images/underlier12/post/444e9d81-dccf-4724-8f2e-7e0beee265d7/image.png)
- 이후 프로세스 2를 실행하게 되며, 2는 Running에 머무르다 실행이 종료되면 Block이 되어 Block state Queue에 들어간다.

![](https://media.vlpt.us/images/underlier12/post/7eed36ae-f122-4c63-bd5d-530ceebdcbdb/image.png)
- 최종적으로 이렇게 된다.
- idle은 Ready 큐에 실행가능한 프로세스가 없는 대기 상태일 때를 의미한다.
- wait가 3칸이니까..



### 선점형과비선점형스케쥴러

**선점형 스케쥴러(Preemptive Scheduling)(후반부에 나옴) :** 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지할 수 있음

**비선점형 스케쥴러(Non-preemptive Scheduling)(기본) :** 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음


*선점형과 비선점형 스케쥴러 차이*
- 비선점형 : 프로세스가 자발정으로 blocking상태로 들어가거나, 실행이 끝날을 때(end)만, 다른 프로세스로 교체가능
- 1.수행 -> 대기 interrupt
- 2.수행 -> 준비 time-out
- 3.대기 -> 준비 wake-up
- 4.수행 종료 
  - 대기 -> 수행 dispatch
![](https://media.vlpt.us/images/underlier12/post/cf64f46a-71c5-4da1-ae60-3f33af64e2cc/image.png)


- 선점형 : 프로세스 running중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체 가능. 

![](/image/OS/s1.png)

```
추가내용 : 
선점형의 경우 위의 1(수행->대기)에서 4까지의 모든 상황에서 발생한다. 어떤 프로세스가 실행되다 time silce를 모두 사용해 time-out이 되거나, IO가 발생하거나, event를 기다려야하는 상황이라면 다른 프로세스에게 CPU사용을 양보해야한다. 다르게 말하면 프로세스를 쫒아 내고 CPU자원을 선점할 수 있다는 뜻이다.(이 때 선점의 근거가 바로 우선순위) 
```
> 현재 OS는 대부분 시분할 선점형 스케쥴링을 사용한다. 이유는 비선점형은 해당 작업이 끝날 때까지 계속 실행되기 때문에 멀티 프로세스 환경에서 응답성을 기대할 수 없다. 
>> 선점형/비선점형 스케쥴링이 아니라, 섬점형/비선점형 커널에 대한 개념도 있는데, 비선점형 커널과 선점형 커널의 차이점은 time-slice동안 interrupt가 들어와도 실행을 보장하느냐 안하는냐이다. 
>> Realtime 실시간 : 컴퓨터에서 실시간은 임계시간(deadline)안에 실행되는 것을 의미한다.


### 스케쥴러동작비교

**[비선점형]**
![](https://github.com/Qussk/TIL/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/OS/s2.png?raw=true)

- ready 에 1,2,3 있는 상황에서 1실행. 

![](/image/OS/s3.png)
- 이런식으로 이동. 비선점형 스케쥴러의 경우 프로세스가 자발적으로 끝나거나 block상태가 되었을 때 전환할수 있으므로 이러한 스케쥴링 형태가 됨. 

![](https://media.vlpt.us/images/underlier12/post/57790976-c598-497e-a1ce-a1c21e36e70e/image.png)
- 비선점형 최종모습


**[선점형]**

![](/image/OS/s4.png)

- 주황색 화살표가 시분할 시스템의 *시간단위*라고 생각하고 이해 진행.

 
 ![](https://github.com/Qussk/TIL/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/OS/s4.png?raw=true)
 
- 스케쥴러 전환시점에 따라 프로세스 가져올 수 있음. 

![](https://github.com/Qussk/TIL/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/OS/s6.png?raw=true)

- 남은 3은 Queue뒤로 쌓이기 때문에 1이 우선순위 됨.

![](https://github.com/Qussk/TIL/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/OS/s7.png?raw=true)

- 3이 2개째일때 block가 되고 다시 2가 wait시간(3칸)이 끝났으므로 ready상태가 됨.

![](https://media.vlpt.us/images/underlier12/post/63c3c154-7863-4dec-a4f9-ece7a44a0dc5/image.png)

- 선점형 최종모습


> 선점형은 응답시간이 길다 치더라고 **어느 시점**이 되면 다른 프로세스를 실행할 수 있기 때문에 응답시간이 매우 줄어듬. 


### 스케쥴러구분
- FIFO(FCFS), SJF, Priority-based 는 어떤 프로세스를 먼저 실행시킬지에 대한 알고리즘(비선점에 가까움)
- RoindRobin은 시분할 시스템을 위한 기본 알고리즘(선점형 스케쥴러)


### 스케쥴링알고리즘조합

![](https://media.vlpt.us/images/underlier12/post/3f3918b5-ea72-4c60-9b9c-16f2185fa7eb/image.png)

- 우선순위 기반
- 1. 각 프로세스의 state(상태) 고려
- 2. CPU 1칸당 1초, 2초를 기준으로 시분할(시간 단위)
- 3. 정적 우선순위 기반으로 다음에 실행할 프로세스를 정하기
- 4. 선점형
1~4를 모두 조합한 스케쥴링.


![](/image/OS/s8.png)

- 3이 처음 실행되고 2,3중에 2가 `Process 2`로 우선순위가 더 높기때문에 선점형에 3,2순으로 가지만, 만약, 반점 찍은 곳을 우선순위를 고려하는 부분이라고 친다면, 굳이 1~2초 간격사이에서는 우선순위를 고려하지 않기때문에 3으로 계속 실행될 수 있음. 일단 후자쪽 알고리즘으로 예시를 들도록 함. 

![](https://media.vlpt.us/images/underlier12/post/21c5af4d-e753-4d84-84dc-16322522cdb6/image.png)
- 최종모습 
> 조합해서 쓰는 경우 "내가 원하는 대로 잘 돌아가는 군.."



*렉? : 마우스 / 키보드 반응이 느린 경우 ?*
> 스케쥴러가 해결해야하는 이슈!
>> 다양하고 복잡한 스케쥴링 알고리즘 필요
- 리눅스 스케쥴러 : O(1), CFS와 같이 다양한 방식으로 변경시도 중
  - 인터렉티브, IO,CPU중심 프로세스로 미리 구분할 수 있다면 보다 개선된 스케쥴링이 가능함
  
  예시) 게임 : 마우스가 끊겨서 이동할때 x, 키보드x, GUI 멈출때 ==> 아, 스케쥴링 알고리즘이 개선되야 겠네...  

*참고 : 프로세스수 가 많이 띄워져 있으면 응답시간이 줄어들 수 밖에 없음*
  


### 인터럽트

- CPU가 프로그램을 실행하고 있을 떄, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술
> 어느 한순간 CPU가 실행하는 명령은 하나! 다른 장치와 어떻게 커뮤니케이션을 할까요??
>> 이벤트가 생김 => 이벤트에 대한 처리(code) 커널발생.
>> 이 중간 단계의 (시그널)알리는 녀석이 인터럽트
>> 말하다가 중간에 끼면 : 아놔.. 인터럽트좀 건들지마..


*인터럽트 필요 이유*

![](https://media.vlpt.us/images/underlier12/post/80436a37-fb1e-4003-ad2e-e83d43e23346/image.png)

> 선점형 스케쥴러 구현
  - 프로세스 running중에 스케쥴러가 이를 중단시키고, 달느 프로세스로 교체하기 위해, 현재 프로세스 실행을 중단시킴
    - 그러러면, 스케쥴러 코드가 실행이 되서, 현 프로세스 실행을 중지시켜야함. 
    
>> IO Device와의 커뮤니케이션
  - 저장매체에서 데이터 처리 완료시, 프로세스를 깨워야함(block tate -> ready state)
>>> 예외 상황 핸들링
  - CPU가 프로그램을 실행하고 있을 떄, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생할 경우, CPU해당 처리를 할 수 있도록 CPU에게 알려줘야함


**정리**

인터럽트 처리 예
- CPU가 프로그램을 실행하고 있을 떄,
  - 입출력 하드웨어 등의 장치 이슈 발생
    - 파일처리가 끝났다는 것을 **운영체제**에게 알려주기
    - 운영체제는 해당 프로세스를 block state에서 실행대기(ready)상태로 프로세스 상태 변경하기
  - 또는 예외 상황이 발생
    - 0으로 나누는 계산이 발생해서, 예외 발생을 운영체제에게 알려주기
    - 운영체제가 해당 프로세스 실행중지/에러표시

```
CPU는 결국에는 pc가 프로그램 카운터가 가르키는 코드에 집중하고 있음. 
외부에서 들어오는 이벤트에 의해, CPU의 동작과 별도로 일을 처리해야할 때,
어떻게 그 정보를 알려줄 것이며, 어떤 정보를 누가 받고 어떻게 각각
처리해주어야 할 것이냐 ==> 중요한 문제가 될 것이고,
이를 운영체제가 운영체제 내부에서 해 놓았다.
(그래서 운영체제 챕터에서 인터럽트를 다루고 있는거임)
```

이벤트와 인터럽트
- 인터럽트는 일종의 이벤트로 불림
- 이벤트에 맞게 운영체제가 처리


### 주요 인터럽트(Interrupt)


**1. 계산하는 코드에서 0으로 나누는 코드 실행시 (Divide-by-zero Interrupt)**
```hello.c
int main()
{
printf("Gello world!\n")
int data;
int divider = 0;
data = 1 / divider;     //(1 나누기 0)이 부분에서 인터럽트 발생.
return 0;
}
```
- CPU에 이 코드를 실행할 때 중지/에러 나옴. 에러는 운영체제가 해준다.
- 프로세스를 죽이고 에러메세지 보여줌.==> 운영체제가 보여줌. 인터럽트 처리 루틴이 이런 메세지를 보여주었다.


**2. 타이머 인터럽트**
  - 선점형 스케쥴러를 위해 필요
  - 어느시점에 간격을 줄여주려는 
  
  ![](https://media.vlpt.us/images/underlier12/post/9ef038cb-48b6-4639-aaaf-144c61b3c30e/image.png)
- 화살표 : 변수값 ++;
- 화살표 간격 : 10ms
- 100ms/ 1/10마다 프로세스 변경(교체) ==> CPU 프로세스 실행.


**3. 입출력(IO) 인터럽트**
  
![](https://media.vlpt.us/images/underlier12/post/5b1e1130-fac3-4446-8474-b1622adc72d0/image.png)


### 인터럽트 종류

- 내부 인터럽트
  - 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
  - 사용자 모드에서 허용되지 않은 명령 또는 공간 접근시 
  - 계산 겨로가가 Overflow/Underflow
  
- 외부 인터럽트
  - 주로 하드웨어에서 발생되는 이벤트(프로그램 외부에서 일어나는 것)
    - 전원이상
    - 기계문제
    - 키보드등 IO관련 이벤트
    - Timer 이벤트
    
*내부 인터럽트는 주로 프로그램 내부에서 발생하므로, 소프트웨어 인터럽트라고도 함*
*외부 인터럽트는 주로 하드웨어에서 발생하므로, 하드웨어 인터럽트라고도 함*


### 시스템 콜 인터럽트
> (뭐야, 시스템 콜도 입터럽트였어 ??)
- 시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, CPU에게 실행시켜야 한다.
- 시스템콜 실제코드
   - eax 레지스터에 시스템 콜 번호를 넣고,
   - ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고,
   - 소프트웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨줌
  
```
   mov eax, 1 <- 시스템콜 번호
   mov ebx, 0 <- 인자
   int 0x80 <- 인터럽트 번호   //소프트웨어 인터럽트 명령
   //int CPU opcode
```

*기계어를 어떻게 컴파일러 되냐?* 
- 시스템 콜은 각각의 번호가 있음
- 시스템 콜에 해당하는 인자값을 넣게 되는데 
- 시스템콜에 해당하는 번호는 (0x80으로 정해놓아져 있음)



### 인터럽트와시스템콜
*(고급)*

- 시스템콜 인터럽트 명령을 호출하면서 0x80값을 넘겨줌 -> <int> op code
 1. CPU는 사용자모드를 커널 모드로 바꿔줌
 2. IDT(Interrupt Descriptor Table)에서 0x80에 해당하는 주소(함수)를 찾아서 실행함 -> 인터럽트 번호 : 주소(코드) 'c언어'에서 `0x80: systemcall()` 이라는 함수를 CPU가 실행
 3. system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동 -> eax: 시스템콜 번호: 함수의 (call콜)
 4. 해당 시스템콜 함수 실행후, 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로레스 다음 코드로 진행
 
 
 ![](https://qu3vipon.github.io/images/idt.png)


**사용자/커널 모드와 프로세스, 인터럽트**

![](https://qu3vipon.github.io/images/process-interrupt.png)

- `프로세스 A`가 시스템콜 호출(int 0x80, eax)
- 커널모드로 변경되면서 systemcallHandler에 해당하는 함수실행
- 돌아오면 `프로세스 A`다시 실행되고 Timer인터럽트가 어느정도의 횟수를 다다르게 되면 (다시 커널모드 Timer interrupt -> ) 스케쥴러 코드가 프로레스를 바꿔서 다른 프로세스 `프로세스 B`를 실행시킴.

> 정말 많이 사용자모드, 커널모드로 바뀌거 가면서 실행됨. 
>> 프로세스는 원래 모듈을 파바박 바꿔가면서 실행함을 감잡아야함.


### 인터럽트와 IDT

- **인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가 기록되어 있음**
  - 이벤트는 각각의 번호를 가지고 있음!!
    - 어디에? **IDT(Interrupt Descriptor)** 에 쓰여있다(기록) 
      - IDT테이블에 "이벤트 번호: 실행코드 주소(함수)"가 맵핑되어 있다. 
    - 언제? 컴퓨터 부팅시 **운영체제**가 기록  
    - 어떤 코드? 운영체제 내부 코드 ==> 커널모드/커널 영역
    
> 커널 영역 : 커널모드에서 실행되는 코드들이 저장되어 있는 (사용자모드와 달리되어 있는) 특정한 메모리 공간
  
- **달리 예를 보면,**
  - 항상 인터럽트 발생시, IDT를 확인
  - 시스템콜 인터럽트 명령은 0x80번호가 미리 정의
  - 인터럽트 0x80에 해당하는 운영체제 코드는 system_call()이라는 함수(리눅스에)
  - 즉, IDT에는 0x80 -> system_call()와 같은 정보가 기록되어 있음
  
- **리눅스의 예**
  - 0~31 : 예외상황 인터럽트(일부는 정의안된 채로 남겨져 있음)
  - 32~47 : 하드웨어 인터럽트(주변장치 종류/갯수에 따라 변경 가능)
  - 128 : 시스템 콜
  
  
### 인터럽트와 프로세스

1. 프로세스 실행 중 인터럽트 발생
2. 현 프로세스 실행 중단
3. 인터럽트 처리 함수 실행(운영체제)
4. 현 프로세스 재실행

![](https://media.vlpt.us/images/underlier12/post/252ea763-d3ff-4d4b-a608-f038ab7a91cf/image.png)

```
강사말 : 
어려우셨죠? 인터럽트에 대해 내부/외부 인터럽트 예만 들어서는 인터럽트가 왜 중요한지 몰랐어요!
그래서 실제 내부 동작과 예를 조금 깊게 보여드린거니 반복해서 봐주시면 됩니당!!
(감동쿠)
```


### 프로세스와 컨텍스트 스위칭
- 프로세스 구조 deep dive

`프로세스 A`에서 스케쥴러가  `프로세스 B`로  바꿀때, 이 메커니즘을 **컨텍스트 스위칭**이라고함
 - 이해하기 위해서 프로세스 구조를 알 필요가 있음
 - 코드작성시 디버깅을 써야할 때 프로세스 구조를 알아야 문제해결이 수월함.
 


### 프로세스구조
: 프로세스의 일반적 구성
프로세스는 다음과 같이 4가지 영역으로 나눌 수 있다.
- text(code) : 일반 코드가 존재
- data : 변수/초기화된 데이터가 존재
- stack : 임시 데이터 (함수 호출, 로컬 변수등)이 존재
- heep: 코드에서 동적으로 생성되는 데이터

![](https://media.vlpt.us/images/underlier12/post/3b0aee47-4b9a-4237-908b-aaeef9de8982/image.png)


### 프로세스와프로그램의동작

![](/image/OS/p1.png)
- 예제는 파이썬임
- `program` 이 컴파일 되면, 0/1 기계어(바이너리라고도 함)로 `Process`에 전달.  
- `program` 의 1~2줄은 함수선언, 3은 변수선언 ==> 변수선언은 곧 메모리에 특정공간을 만들어서 데이터를 저장하고 빼오기도 하는 공간을 만듦. ==> DATA에 넣는다. , 초기값인듯
- 4번줄 파라미터 값(인자 값) a=1,b=2은 스택에 저장.(return address로 실행.)
- 스택은 함수를 위한 공간
- 별도의 공간 힙.
- 스택과 힙은 동적 공간


![](https://media.vlpt.us/images/underlier12/post/4e0925c8-3544-45d6-9e83-90734321a7fa/image.png)

PC(Program Counter)가 코드가 존재하는 주소(옆에 적힌 메모리 주소)를 하나하나 가리키며 실행이 되고 실행 중 필요시 stack, heap, data 영역에 read/write를 실시한다.

![](https://media.vlpt.us/images/underlier12/post/9ebe6d45-8993-4d03-9c14-595d6cb643d4/image.png)

- 0006h은 return address.
- 스택은 함수실행 순서(코드 아래에서 위)에 따라 위에서 아래로 추가됐고, 들어온 순서대로 없앰. 아래에서 위로 없어짐.




